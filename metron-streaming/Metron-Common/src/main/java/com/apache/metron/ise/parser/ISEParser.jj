options{  CHOICE_AMBIGUITY_CHECK = 3;  OTHER_AMBIGUITY_CHECK = 2;  //DEBUG_PARSER=true
  //DEBUG_LOOKAHEAD=true
  //DEBUG_TOKEN_MANAGER=true
  ERROR_REPORTING = true;  JAVA_UNICODE_ESCAPE = true;  UNICODE_INPUT = true;  IGNORE_CASE = true;  SUPPORT_CLASS_VISIBILITY_PUBLIC = false;  FORCE_LA_CHECK = true;  CACHE_TOKENS = true;  SANITY_CHECK = true;  STATIC = false;  //KEEP_LINE_COLUMN=true;
}PARSER_BEGIN(ISEParser)package com.opensoc.ise.parser;import java.io.*;import java.util.*;import org.json.simple.*;/**
* Basic ISE data parser generated by JavaCC. 
*/public class ISEParser implements Serializable{  private boolean nativeNumbers = false;  public ISEParser()  { //do nothing
  }  public ISEParser(String input)  {    this (new StringReader(input));  }  /**
	* Parses a ISE String into a JSON object {@code Map}.
	*/  public JSONObject parseObject() throws ParseException  {    JSONObject toReturn = object();    if (!ensureEOF()) throw new IllegalStateException("Expected EOF, but still had content to parse");    return toReturn;  }}PARSER_END(ISEParser)// Ignore commentsSKIP :{  < C_SINGLE_COMMENT : "//" (~[ "\n", "\r", "\f" ])* < EOL >>| < C_MULTILINE_COMMENT : "/*" (~[ ])* "*/" >| < SH_SINGLE_COMMENT : "#" (~[ "\n", "\r", "\f" ])* < EOL >>  /*| < WHITESPACE :    " "  | "\t" >*/| < EOL :    "\n"  | "\r"  | "\f" >}// Common tokens
TOKEN :{  < COMMA : "," >| < EQUALS : "=" >| < SLASH : "\\" >| < TAG : "(tag=0)" >}// Null token/*TOKEN :{  //< NULL : "null" >}*/// String tokens
TOKEN :{  //< SYMBOL : ([ "a"-"z", "A"-"Z", "0", "1"-"9", " ", "\t" , ":" , "-" , "." ])+ >  < STRING_BODY :    (      (~[ "\"", "\r", "\n", "\f", "\t", "=", "," ])    |      (        "\\"        (          "r"        | "n"        | "f"        | "\\"        | "/"        | "\""        | "b"        | "t"        | ","        )      )    )+ >| < BRACED_STRING :    (      "{" (~[ "{", "}" ])+ "}"    ) >}boolean ensureEOF() :{}{  (< COMMA >)? < EOF >  {    return true;  }}JSONObject innerMap() :{  final JSONObject json = new JSONObject();  String key;  Object value;}{  key = objectKey() < EQUALS > value = value()  {    json.put(key, value);  }  {    key = null;    value = null;  }  (    < SLASH > < COMMA > key = objectKey() < EQUALS > value = value()    {      json.put(key, value);    }    {      key = null;      value = null;    }  )*  {    return json;  }}JSONObject object() :{  final JSONObject json = new JSONObject();  String key;  Object value;}{  key = objectKey() < EQUALS > value = value()  {    json.put(key, value);  }  {    key = null;    value = null;  }  (    (      LOOKAHEAD(2)      < COMMA > key = objectKey() < EQUALS > value = value()      {        json.put(key, value);      }      {        key = null;        value = null;      }    )*  | LOOKAHEAD(2)    < COMMA > < EOF >  )  // ensureEOF()  {    return json;  }}String objectKey() :{  String k;}{  (    k = string()  )  {    //  System.out.println("key == " + k);    return k.trim();  }}Object value() :{  Object x;  String eof = "EOF";  Map m = null;}{  (    LOOKAHEAD(< COMMA >)    x = nullValue()  | LOOKAHEAD(innerMap())    x = innerMap()  | x = tagString()  | LOOKAHEAD(< EOF >)    x = blankValue()  | LOOKAHEAD(braced_string())    x = braced_string()  | LOOKAHEAD(2)    x = string()  )  {    //  System.out.println("val == " + x);    //if (x instanceof Map) return "Map";    //return (String) x;    return x;  }}String nullValue() :{}{  {    return null;  }}String tagString() :{  String output = "(tag=0)";}{  < TAG > < STRING_BODY >  {    return output + token.image;  }}String blankValue() :{}{  {    return null;  }}String string() :{  String s;}{  < STRING_BODY >  {    return token.image.trim();  }}String braced_string() :{  String s;}{  < BRACED_STRING >  {    //  System.out.println("braced == " + token.image);    s = token.image;  }  < COMMA >  {    return s.trim();  }}